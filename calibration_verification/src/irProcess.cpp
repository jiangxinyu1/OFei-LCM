/*
 * @Author: jiangxinyu
 * @Date: 2021-08-25 10:38:17
 * @LastEditTime: 2021-09-06 09:50:18
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: /calibration_verification/src/convertedPointCloudPuber.cpp
 */

#include <iostream>
#include "ros/ros.h"
#include "std_msgs/String.h"
#include "geometry_msgs/TransformStamped.h"
#include "sensor_msgs/Image.h"
#include <opencv2/opencv.hpp>
#include "image_transport/image_transport.h"
#include "opencv2/highgui/highgui.hpp"

// Eigen
#include <Eigen/Dense>

/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////
ros::Publisher pub1;

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ir_call_back(const sensor_msgs::ImageConstPtr &ir_image)
{
    cv::Mat ir_src_in;
    {
        uint8_t* irData [224][114];
        memcpy(irData,ir_image->data.data(),ir_image->data.size()*sizeof(uint16_t));
        cv::Mat src (cv::Size(224, 114), CV_16UC1, irData);
        // convertScaleAbs(src,src);
        ir_src_in = src.clone();
    }
    cv::Mat resultImage;
    ir_src_in.convertTo(ir_src_in,CV_8U);
    cv::equalizeHist(ir_src_in,resultImage);
    resultImage.convertTo(resultImage,CV_16U);
    // 转成Ros消息发布
    sensor_msgs::Image ir_processed;
    ir_processed.encoding = "16UC1";
    ir_processed.width = ir_image->width;
    ir_processed.height = ir_image->height;
    ir_processed.header.frame_id = ir_image->header.frame_id;
    ir_processed.header.stamp = ir_image->header.stamp;
    ir_processed.data.resize(ir_image->data.size());
    memcpy(ir_processed.data.data(), resultImage.data, ir_image->data.size()*sizeof(uint8_t));
    std::cout << ir_image->data.size() << "\n";
    std::cout << ir_processed.data.size() << "\n";
    pub1.publish(ir_processed);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int main(int argc, char **argv)
{
    ros::init(argc, argv, "IRProcess_node");
    ros::NodeHandle n;
    ros::Subscriber Suber = n.subscribe("ir_image", 50, ir_call_back);
    pub1 = n.advertise<sensor_msgs::Image>("ir_processed", 50);
    ros::spin();
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////